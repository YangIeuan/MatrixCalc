# 矩阵与矩阵相乘

## 通用算法

矩阵与矩阵相乘涉及三个分量的遍历：`row_A = i`, `col_A = row_B = k`, `col_B = j`，因此矩阵相乘涉及到三重遍历，不同的遍历顺序会引出不同的算法，下面依次展开来看：

ikj型：最外层循环是`$A$`的行，最内层的循环是矩阵$`B`$的列，因此更新最慢的是$`C`$的行，更新最快的是$`C`$的列，因此按向量形式表示为：
```matlab
for i = 1 : m
    for k = 1 : p
        C(i,:) = A(i,k)B(k,:) + C(i,:)
    end
end
```
可以看出，最内层循环表示成了SAXPY运算。

ijk型：最外层循环是$`A`$的行，最内层的循环是矩阵$`B`$的行，因此更新最慢的是$`C`$的行，更新最快的是中间变量（乘积运算），按向量形式表示为：
```matlab
for i = 1 : m
    for j = 1 : n
        C(i,j) = A(i,:)B(:,j) + C(i, j)    
    end
end
```
可以看出，最内层循环表示成了点积运。

kij型：最外层循环是$`B`$的行，最内层的循环是矩阵$`B`$的列，因此更新最慢的是中间变量（乘积运算），更新最快的是$`C`$的列，无法按向量形式表示，以矩阵形式表示：
```matlab
for k = 1 : p
    C = A(:,k)B(k,:) + C
end
```
可以看出，内部两层表示为秩1修正。

kji型：最外层循环是$`B`$的行，最内层的循环是矩阵$`A`$的行，因此更新最慢的是中间变量（乘积运算），更新最快的是$`C`$的行，无法按向量形式表示，以矩阵形式表示：
```matlab
for k = 1 : p
    C = A(:,k)B(k,:) + C
end
```
可以看出，内部两层表示为秩1修正。

jik型：最外层循环是$`B`$的列，最内层的循环是矩阵$`B`$的行，因此更新最慢的是$`C`$的列，更新最快的是中间变量（乘积运算），以向量形式表示：
```matlab
for j = 1 : n
    for i = 1 : m
        C(i,j) = A(i,:)B(:,j) + C(i, j)
    end
end
```
可以看出，最内层循环表示成了点积运。


jki型：最外层循环是`$B$`的列，最内层的循环是矩阵$`A`$的列行，因此更新最慢的是$`C`$的列，更新最快的是$`C`$的行，因此按向量形式表示为：
```matlab
for j = 1 : n
    for k = 1 : p
        C(:,j) = A(:,k)B(k,j) + C(:,j)
    end
end
```
可以看出，最内层循环表示成了SAXPY运算。

综上，可以看出，总共六种型，三类算法，列出表格如下：


|序号|型号|类型|代码|时间复杂度|空间复杂度|
|--|--|--|--|--|--|
|1|ikj|SAXPY|[MmultMSaxpy](src/mmm.cpp#MmultMSaxpy)|$`O(mnp)`$|0|
|2|ijk|点积|[MmultMDot](src/mmm.cpp#MmultMDot)|$`O(mnp)`$|0|
|3|kij|秩1修正|[MmultMGer1](src/mmm.cpp#MmultMGer1)|$`O(mnp)`$|0|
|4|kji|秩1修正|[MmultMGer1](src/mmm.cpp#MmultMGer1)|$`O(mnp)`$|0|
|5|jik|点积|[MmultMDot](src/mmm.cpp#MmultMDot)|$`O(mnp)`$|0|
|6|jki|SAXPY|[MmultMSaxpy](src/mmm.cpp#MmultMSaxpy)|$`O(mnp)`$|0|

## 利用结构

常见的特殊结构有：带状矩阵、对称矩阵，这两种矩阵元素个数都要远小于普通的稠密矩阵。因此算法的时间和空间复杂度都可以降低。

### 带状矩阵

对任何$`i - j > p`$都有$`a_{ij} = 0`$，就称$`A`$具有下带宽$`p`$；相应的，如果对于任何$`j - i > q`$都有$`a_{ij} = 0`$，就称$`A`$具有上带宽$`q`$。

**几种特殊的带状矩阵**：

|矩阵类型|下带宽|上带宽|
|--|--|--|
|对角矩阵|0|0|
|上三角矩阵|0|n-1|
|下三角矩阵|m-1|0|
|三对角矩阵|1|1|
|上双对角矩阵|0|1|
|下双对角矩阵|1|0|
|上Hessenberg矩阵|1|n-1|
|下Hessenberg矩阵|m-1|1|

#### 对角矩阵

存储：对角矩阵可以直接存储为向量

计算：任何矩阵左乘以对角矩阵，就是对矩阵本身的行向量加权；右乘对角矩阵就是对矩阵本身的列向量加权。

时间复杂度：$`O(mn)`$

#### 三角矩阵

存储：三角矩阵存储没有可改进的方法

计算：同为上三角的两个矩阵$`A, B`$相乘，可以进行优化，$`C = AB`$，有$`c_{ij} = \sum_{k=i}^ja_{ik}b_{kj}`$。可以看出，针对分量$`k`$只需对$`i \leq k \leq j`$的区间进行计算，其他的部分计算出来的必定是0。

时间复杂度：
$$
\begin{align*}
T &= \sum_{i=1}^n\sum_{j=i}^n\sum_{k=1}^{j-i}2 \\
  &= \sum_{i=1}^n\sum_{j=i}^n(j-i)2\\
  &= \sum_{i=1}^n\left(n(n+1) - (i-1)i\right) - 
  \sum_{i=1}^n2(n-i+1)i\\
  &= \sum_{i=1}^n(n-i)^2 + O(n^2)\\
  &= \sum_{i=1}^ni^2 + O(n^2)\\
  &= \frac{1}{3}n^3 + O(n^2)

\end{align*}
$$

#### 带状矩阵的存储

带状矩阵的上带宽和下带宽决定了每一列最多非零元的个数。取$`j = q+1`$, 于是$`a_{1j} > 0`$（由下带宽保证），并且$`a_{j+p+1,j} > 0`$（由上带宽保证）；从而该列共有$`j+p+1-1 = p+q+1`$个元素。

因此，我们可以将带状矩阵的元素存储在一个$`(p+q+1) \times n`$大小的矩阵中$`Ab`$。转存方式为，固定$`j=q+1`$的列元素不变，其他的元素移动的使得其他列的$`a_{jj}`$元素都与$`a_{p+1,p+1}`$在统一条水平线上。由于每一列移动的个数相同，且与$`j`$呈正相关，不妨假设移动的函数为$`f(j) = kj + t`$。根据$`f(q+1) = 0`$以及$`f(1) = q`$，可得$`k = -1`$，$`t = q + 1`$，从而有：

$$
`a_{ij} = Ab_{i + f(j),j} = Ab_{i-j+q+1,j}`
$$

#### 使用带状矩阵转存后的矩阵进行gaxpy

带状矩阵每一列只有非零元参与更新，因此在每次都需要找出Ab矩阵的行标以及原矩阵中A的对应元素行标：





算法：

```matlab
for j = 1 : n
    
end

```

---
[父目录:矩阵乘法](../ReadME.md)